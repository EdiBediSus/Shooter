<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Shooter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Courier New', monospace; background: #000; }
        #hud { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 18px; z-index: 10; display: flex; gap: 40px; font-weight: bold; }
        .hud-value { font-size: 24px; color: #0f8; }
        #weaponName { position: absolute; bottom: 30px; right: 30px; color: #0f8; font-size: 20px; font-weight: bold; }
        #healthBar { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 200px; height: 4px; background: rgba(255,255,255,0.1); }
        #healthBarFill { height: 100%; background: linear-gradient(90deg, #f44, #0f8); transition: width 0.3s; width: 100%; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; z-index: 10; transition: 0.1s; }
        .ch { position: absolute; background: rgba(255,255,255,0.9); box-shadow: 0 0 4px #000; }
        #hitmarker { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; opacity: 0; z-index: 15; }
        .hm { position: absolute; background: #fff; width: 3px; height: 12px; box-shadow: 0 0 8px #0f8; }
        @keyframes hit { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } }
        #killFeed { position: absolute; top: 20px; right: 20px; color: #fff; font-size: 14px; z-index: 10; }
        .kill { background: rgba(0,0,0,0.7); padding: 8px 12px; margin-bottom: 4px; border-left: 3px solid #0f8; animation: slideIn 0.3s; }
        @keyframes slideIn { from { transform: translateX(100px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        #damageOverlay { position: absolute; inset: 0; background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.3)); opacity: 0; pointer-events: none; z-index: 5; transition: 0.3s; }
        #reloadInd { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); color: #0f8; font-size: 16px; opacity: 0; transition: 0.2s; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: #fff; padding: 60px; text-align: center; display: none; z-index: 20; border: 2px solid #0f8; }
        #gameOver h1 { margin-bottom: 20px; color: #f44; font-size: 48px; }
        #gameOver button { margin-top: 30px; padding: 15px 40px; font-size: 18px; cursor: pointer; background: #0f8; color: #000; border: none; font-weight: bold; }
        #instructions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; text-align: center; background: rgba(0,0,0,0.8); padding: 40px; z-index: 25; border: 2px solid #0f8; }
        #instructions button { margin-top: 30px; padding: 15px 40px; font-size: 18px; cursor: pointer; background: #0f8; color: #000; border: none; font-weight: bold; }
        .hide { display: none !important; }
    </style>
</head>
<body>
    <div id="instructions"><h2>FPS SHOOTER</h2><p>WASD - Move | Space - Jump | Mouse - Look | Click - Shoot | R - Reload</p><p>1 - Rifle | 2 - Shotgun | 3 - Sniper | 4 - Knife</p><button onclick="start()">START</button></div>
    <div id="hud" class="hide"><div>HP <span class="hud-value" id="hp">100</span></div><div>AMMO <span class="hud-value" id="ammo">30</span><span id="maxAmmo">/30</span></div><div>SCORE <span class="hud-value" id="score">0</span></div></div>
    <div id="weaponName" class="hide">RIFLE</div>
    <div id="healthBar" class="hide"><div id="healthBarFill"></div></div>
    <div id="crosshair" class="hide"><div class="ch" style="width:2px;height:8px;left:50%;top:-12px;transform:translateX(-50%)"></div><div class="ch" style="width:2px;height:8px;left:50%;bottom:-12px;transform:translateX(-50%)"></div><div class="ch" style="width:8px;height:2px;left:-12px;top:50%;transform:translateY(-50%)"></div><div class="ch" style="width:8px;height:2px;right:-12px;top:50%;transform:translateY(-50%)"></div></div>
    <div id="hitmarker"><div class="hm" style="left:0;top:0;transform:rotate(45deg);transform-origin:top left"></div><div class="hm" style="right:0;top:0;transform:rotate(-45deg);transform-origin:top right"></div><div class="hm" style="left:0;bottom:0;transform:rotate(-45deg);transform-origin:bottom left"></div><div class="hm" style="right:0;bottom:0;transform:rotate(45deg);transform-origin:bottom right"></div></div>
    <div id="killFeed"></div>
    <div id="damageOverlay"></div>
    <div id="reloadInd">RELOADING...</div>
    <div id="gameOver"><h1>GAME OVER</h1><div>Score: <span id="finalScore">0</span></div><button onclick="location.reload()">AGAIN</button></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene,cam,rend,enemies=[],bullets=[],gunGrp,hp=100,ammo=30,score=0,locked=0,fwd=0,bck=0,lft=0,rgt=0;
        let yaw=0,pitch=0,recoil={x:0,y:0},sway={x:0,y:0},shake={x:0,y:0},mouse={x:0,y:0},bob=0,vel={y:0},grnd=1;
        let walls=[],obs=[],reload=0,lastShot=0,curWep=0,gunBob={x:0,y:0,z:0},customTex={};
        const wpns=[
            {n:'RIFLE',a:30,ma:30,dmg:34,fr:150,rec:0.08,rng:100},
            {n:'SHOTGUN',a:8,ma:8,dmg:100,fr:800,rec:0.2,rng:30,pel:8},
            {n:'SNIPER',a:5,ma:5,dmg:100,fr:1200,rec:0.3,rng:200},
            {n:'KNIFE',a:999,ma:999,dmg:100,fr:500,rec:0,rng:3,mel:1}
        ];

        function makeTex(data,w,h,rep){
            let t=new THREE.DataTexture(new Uint8Array(data),w,h,THREE.RGBAFormat);
            t.needsUpdate=1;t.magFilter=THREE.NearestFilter;t.wrapS=t.wrapT=THREE.RepeatWrapping;
            if(rep)t.repeat.set(rep[0],rep[1]);return t;
        }

        function init(){
            // Custom texture loader
            let texLoader=new THREE.TextureLoader();
            customTex={
                grass:null,wall:null,obstacle:null,enemy:null,
                rifle:null,shotgun:null,sniper:null,knife:null
            };
            // Load custom textures (place PNG files in same folder as HTML)
            ['grass','wall','obstacle','enemy','rifle','shotgun','sniper','knife'].forEach(n=>{
                texLoader.load(n+'.png',t=>{
                    t.wrapS=t.wrapT=THREE.RepeatWrapping;
                    t.magFilter=THREE.NearestFilter;
                    if(n==='grass')t.repeat.set(50,50);
                    if(n==='wall')t.repeat.set(20,4);
                    if(n==='obstacle')t.repeat.set(4,4);
                    customTex[n]=t;
                    console.log('Loaded '+n+'.png');
                },undefined,e=>console.log('Could not load '+n+'.png (file not found)'));
            });

            scene=new THREE.Scene();
            scene.background=new THREE.Color(0x87ceeb);
            scene.fog=new THREE.Fog(0x87ceeb,0,120);
            cam=new THREE.PerspectiveCamera(80,innerWidth/innerHeight,0.1,1000);
            cam.position.set(0,1.7,0);
            rend=new THREE.WebGLRenderer({antialias:1});
            rend.setSize(innerWidth,innerHeight);
            rend.shadowMap.enabled=1;
            document.body.appendChild(rend.domElement);

            scene.add(new THREE.AmbientLight(0xffffff,0.6));
            let dl=new THREE.DirectionalLight(0xffffff,0.8);
            dl.position.set(20,30,20);
            dl.castShadow=1;
            dl.shadow.mapSize.width=2048;
            dl.shadow.mapSize.height=2048;
            scene.add(dl);

            // Better grass texture
            let gd=[76,140,43,255,68,124,39,255,82,156,47,255,72,132,41,255,78,148,45,255,70,128,40,255,80,152,46,255,74,136,42,255].flatMap(x=>[x,x,x,255]);
            let gt=makeTex(gd,4,2,[50,50]);
            let gnd=new THREE.Mesh(new THREE.PlaneGeometry(100,100),new THREE.MeshStandardMaterial({map:gt,roughness:0.9}));
            gnd.rotation.x=-Math.PI/2;gnd.receiveShadow=1;scene.add(gnd);
            // Apply custom texture when loaded
            setTimeout(()=>{
                if(customTex.grass){
                    gnd.material.map=customTex.grass;
                    gnd.material.needsUpdate=1;
                    console.log('Applied grass texture');
                }
            },200);

            // Better brick wall texture
            let wd=[90,70,60,255,85,65,55,255,95,75,65,255,88,68,58,255,92,72,62,255,86,66,56,255,94,74,64,255,89,69,59,255].flatMap(x=>[x,x,x,255]);
            let wt=makeTex(wd,4,2,[20,4]);
            let wm=new THREE.MeshStandardMaterial({map:wt,roughness:0.8});
            [[50,5,0.5,0,2.5,-25],[50,5,0.5,0,2.5,25],[0.5,5,50,25,2.5,0],[0.5,5,50,-25,2.5,0]].forEach(c=>{
                let w=new THREE.Mesh(new THREE.BoxGeometry(c[0],c[1],c[2]),wm.clone());
                w.position.set(c[3],c[4],c[5]);w.castShadow=w.receiveShadow=1;scene.add(w);walls.push(w);
            });
            // Apply custom texture when loaded
            setTimeout(()=>{
                if(customTex.wall){
                    walls.forEach(w=>{
                        w.material.map=customTex.wall;
                        w.material.needsUpdate=1;
                    });
                    console.log('Applied wall texture');
                }
            },200);

            // Better concrete texture
            let od=[120,120,125,255,110,110,115,255,115,115,120,255,105,105,110,255,118,118,123,255,108,108,113,255,122,122,127,255,112,112,117,255].flatMap(x=>[x,x,x,255]);
            let ot=makeTex(od,4,2,[4,4]);
            let om=new THREE.MeshStandardMaterial({map:ot,roughness:0.7});
            [[8,8],[-8,-8],[12,-12],[-12,12],[0,18],[18,0],[-18,0],[0,-18]].forEach(p=>{
                let o=new THREE.Mesh(new THREE.BoxGeometry(2.5,2,2.5),om.clone());
                o.position.set(p[0],1,p[1]);o.castShadow=o.receiveShadow=1;scene.add(o);obs.push(o);
            });
            // Apply custom texture when loaded
            setTimeout(()=>{
                if(customTex.obstacle){
                    obs.forEach(o=>{
                        o.material.map=customTex.obstacle;
                        o.material.needsUpdate=1;
                    });
                    console.log('Applied obstacle texture');
                }
            },200);

            for(let i=0;i<5;i++)spawnEnemy();
            gunGrp=new THREE.Group();cam.add(gunGrp);scene.add(cam);createWep();
            
            document.addEventListener('mousemove',e=>{
                if(!locked)return;
                yaw-=e.movementX*0.002;
                pitch=Math.max(-1.57,Math.min(1.57,pitch-e.movementY*0.002));
                mouse.x=e.movementX*0.002;
                mouse.y=e.movementY*0.002;
            });
            document.addEventListener('mousedown',shoot);
            document.addEventListener('keydown',e=>{
                if(e.code=='KeyW')fwd=1;
                if(e.code=='KeyS')bck=1;
                if(e.code=='KeyA')lft=1;
                if(e.code=='KeyD')rgt=1;
                if(e.code=='Space'&&grnd){vel.y=0.25;grnd=0;}
                if(e.code=='KeyR'&&ammo<wpns[curWep].ma&&!reload)doReload();
                if(e.code=='Digit1')switchWep(0);
                if(e.code=='Digit2')switchWep(1);
                if(e.code=='Digit3')switchWep(2);
                if(e.code=='Digit4')switchWep(3);
            });
            document.addEventListener('keyup',e=>{
                if(e.code=='KeyW')fwd=0;
                if(e.code=='KeyS')bck=0;
                if(e.code=='KeyA')lft=0;
                if(e.code=='KeyD')rgt=0;
            });
            addEventListener('resize',()=>{cam.aspect=innerWidth/innerHeight;cam.updateProjectionMatrix();rend.setSize(innerWidth,innerHeight);});
            animate();
        }

        function createWep(){
            while(gunGrp.children.length)gunGrp.remove(gunGrp.children[0]);
            if(curWep===3){
                let blade=new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.008,0.4,8),new THREE.MeshStandardMaterial({color:0xcccccc,metalness:0.95,roughness:0.1}));
                blade.rotation.z=Math.PI/2;blade.position.set(0.3,-0.25,-0.4);gunGrp.add(blade);
                let handle=new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.18,8),new THREE.MeshStandardMaterial({color:0x2a1810,roughness:0.8}));
                handle.rotation.z=Math.PI/2;handle.position.set(0.3,-0.3,-0.6);gunGrp.add(handle);
            }else if(curWep===2){
                let barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.025,0.8,12),new THREE.MeshStandardMaterial({color:0x1a1a1a,metalness:0.85,roughness:0.2}));
                barrel.rotation.z=Math.PI/2;barrel.position.set(0.3,-0.22,-0.75);gunGrp.add(barrel);
                let scope=new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.25,8),new THREE.MeshStandardMaterial({color:0x0a0a0a,metalness:0.6,roughness:0.3}));
                scope.rotation.z=Math.PI/2;scope.position.set(0.3,-0.14,-0.5);gunGrp.add(scope);
                let body=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.14,0.35),new THREE.MeshStandardMaterial({color:0x2a2a2a,metalness:0.7,roughness:0.4}));
                body.position.set(0.3,-0.28,-0.35);gunGrp.add(body);
            }else if(curWep===1){
                let barrel=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.5),new THREE.MeshStandardMaterial({color:0x2a2a2a,metalness:0.8,roughness:0.3}));
                barrel.position.set(0.3,-0.25,-0.6);gunGrp.add(barrel);
                let body=new THREE.Mesh(new THREE.BoxGeometry(0.14,0.18,0.35),new THREE.MeshStandardMaterial({color:0x4a3020,roughness:0.6}));
                body.position.set(0.3,-0.28,-0.3);gunGrp.add(body);
                let pump=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.05,0.18),new THREE.MeshStandardMaterial({color:0x3a3a3a,metalness:0.7}));
                pump.position.set(0.3,-0.35,-0.42);gunGrp.add(pump);
            }else{
                let barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.55,12),new THREE.MeshStandardMaterial({color:0x1a1a1a,metalness:0.85,roughness:0.2}));
                barrel.rotation.z=Math.PI/2;barrel.position.set(0.3,-0.25,-0.65);gunGrp.add(barrel);
                let body=new THREE.Mesh(new THREE.BoxGeometry(0.11,0.15,0.3),new THREE.MeshStandardMaterial({color:0x2a2a2a,metalness:0.75,roughness:0.3}));
                body.position.set(0.3,-0.28,-0.35);gunGrp.add(body);
                let grip=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.18,0.11),new THREE.MeshStandardMaterial({color:0x3a3a3a,roughness:0.7}));
                grip.position.set(0.3,-0.4,-0.32);gunGrp.add(grip);
                let mag=new THREE.Mesh(new THREE.BoxGeometry(0.055,0.14,0.08),new THREE.MeshStandardMaterial({color:0x0a0a0a,metalness:0.5}));
                mag.position.set(0.3,-0.45,-0.28);gunGrp.add(mag);
            }
        }

        function switchWep(i){if(reload)return;curWep=i;ammo=wpns[i].a;createWep();updateHUD();document.getElementById('weaponName').textContent=wpns[i].n;}
        function start(){document.getElementById('instructions').classList.add('hide');['hud','healthBar','crosshair','weaponName'].forEach(id=>document.getElementById(id).classList.remove('hide'));rend.domElement.requestPointerLock();document.addEventListener('pointerlockchange',()=>locked=document.pointerLockElement===rend.domElement);}
        
        function spawnEnemy(){
            let mat=new THREE.MeshStandardMaterial({color:0xff3366,emissive:0x660033,roughness:0.7});
            if(customTex.enemy)mat.map=customTex.enemy;
            let e=new THREE.Mesh(new THREE.BoxGeometry(0.8,1.8,0.8),mat);
            let a=Math.random()*6.28,d=8+Math.random()*12;
            e.position.set(Math.cos(a)*d,0.9,Math.sin(a)*d);e.castShadow=1;e.hp=100;e.spd=0.08;scene.add(e);enemies.push(e);
        }

        function shoot(){
            let w=wpns[curWep];
            if(!locked||ammo<=0||reload||Date.now()-lastShot<w.fr)return;
            if(w.mel){meleeAtk();return;}
            lastShot=Date.now();ammo--;wpns[curWep].a=ammo;updateHUD();
            recoil.y+=w.rec;recoil.x+=(Math.random()-0.5)*w.rec*0.5;
            shake.x=(Math.random()-0.5)*0.03;shake.y=(Math.random()-0.5)*0.03;

            let dir=new THREE.Vector3(0,0,-1);
            dir.applyQuaternion(cam.quaternion);

            let rc=new THREE.Raycaster();
            let pel=w.pel||1;
            for(let i=0;i<pel;i++){
                let spread=new THREE.Vector2((Math.random()-0.5)*(pel>1?0.15:0.01),(Math.random()-0.5)*(pel>1?0.15:0.01));
                rc.setFromCamera(spread,cam);
                let hits=rc.intersectObjects(enemies);
                if(hits.length>0&&hits[0].distance<w.rng){
                    hitEnemy(hits[0].object,w.dmg/pel);
                    
                    // Bullet tracer
                    let tracer=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,hits[0].distance,4),new THREE.MeshBasicMaterial({color:0xffff88,transparent:1,opacity:0.8}));
                    tracer.rotation.x=Math.PI/2;
                    tracer.position.copy(cam.position);
                    let td=new THREE.Vector3().subVectors(hits[0].point,cam.position);
                    tracer.position.add(td.multiplyScalar(0.5));
                    tracer.lookAt(hits[0].point);
                    scene.add(tracer);
                    setTimeout(()=>scene.remove(tracer),50);
                }
            }

            // Muzzle flash
            let f=new THREE.Mesh(new THREE.SphereGeometry(0.15),new THREE.MeshBasicMaterial({color:0xffaa00}));
            f.position.copy(cam.position).add(dir.multiplyScalar(0.8));
            scene.add(f);
            setTimeout(()=>scene.remove(f),30);
        }

        function meleeAtk(){
            lastShot=Date.now();gunBob.z=-0.8;
            setTimeout(()=>gunBob.z=0,300);
            enemies.forEach(e=>{if(e.position.distanceTo(cam.position)<3)hitEnemy(e,100);});
        }

        function hitEnemy(e,dmg){
            e.hp-=dmg;
            document.getElementById('hitmarker').style.animation='none';
            setTimeout(()=>document.getElementById('hitmarker').style.animation='hit 0.2s',10);
            let hd=new THREE.Vector3().subVectors(e.position,cam.position).normalize().multiplyScalar(0.3);
            e.position.add(hd);
            e.material.emissive.setHex(0xff0000);
            setTimeout(()=>e.material&&e.material.emissive.setHex(0x660033),100);
            if(e.hp<=0){
                for(let j=0;j<10;j++){
                    let p=new THREE.Mesh(new THREE.SphereGeometry(0.08),new THREE.MeshBasicMaterial({color:0xff3366}));
                    p.position.copy(e.position);
                    p.vel=new THREE.Vector3((Math.random()-0.5)*0.3,Math.random()*0.3,(Math.random()-0.5)*0.3);
                    p.life=0;scene.add(p);bullets.push(p);
                }
                scene.remove(e);enemies=enemies.filter(x=>x!==e);score+=100;updateHUD();
                let m=document.createElement('div');m.className='kill';m.textContent='+ KILL';
                document.getElementById('killFeed').appendChild(m);
                setTimeout(()=>m.remove(),3000);setTimeout(spawnEnemy,2000);
            }
        }

        function doReload(){
            reload=1;
            document.getElementById('reloadInd').style.opacity='1';
            setTimeout(()=>{
                ammo=wpns[curWep].ma;wpns[curWep].a=ammo;reload=0;
                updateHUD();document.getElementById('reloadInd').style.opacity='0';
            },1500);
        }

        function checkCol(pos,rad=0.4){
            let pb=new THREE.Box3().setFromCenterAndSize(pos,new THREE.Vector3(rad*2,1.7,rad*2));
            for(let w of walls.concat(obs)){
                let box=new THREE.Box3().setFromObject(w);
                if(pb.intersectsBox(box))return box;
            }
            return null;
        }

        function updateHUD(){
            document.getElementById('hp').textContent=hp;
            document.getElementById('ammo').textContent=ammo;
            document.getElementById('maxAmmo').textContent='/'+wpns[curWep].ma;
            document.getElementById('score').textContent=score;
            document.getElementById('healthBarFill').style.width=hp+'%';
        }

        function animate(){
            requestAnimationFrame(animate);
            if(!locked||hp<=0){rend.render(scene,cam);return;}

            let spd=0.18,dir=new THREE.Vector3();
            if(fwd)dir.z-=1;if(bck)dir.z+=1;if(lft)dir.x-=1;if(rgt)dir.x+=1;
            if(dir.length()>0){
                dir.normalize().applyQuaternion(cam.quaternion);dir.y=0;
                let np=cam.position.clone().add(dir.multiplyScalar(spd));
                if(!checkCol(np))cam.position.copy(np);
                bob+=0.15;
            }

            // Improved jump collision
            vel.y-=0.015;
            let ny=cam.position.y+vel.y;
            let tp=cam.position.clone();tp.y=ny;
            let col=checkCol(tp);
            
            if(col){
                if(vel.y<0&&ny<col.max.y+1.7){
                    cam.position.y=col.max.y+1.7;
                    vel.y=0;grnd=1;
                }else if(vel.y>0){
                    vel.y=0;
                }
            }else{
                cam.position.y=ny;
                if(cam.position.y<=1.7){
                    cam.position.y=1.7;vel.y=0;grnd=1;
                }else{grnd=0;}
            }

            // Smooth animations
            recoil.x+=(0-recoil.x)*0.15;recoil.y+=(0-recoil.y)*0.15;
            sway.x+=(mouse.x-sway.x)*0.08;sway.y+=(mouse.y-sway.y)*0.08;
            mouse.x*=0.85;mouse.y*=0.85;
            shake.x*=0.85;shake.y*=0.85;
            gunBob.x+=(Math.cos(bob)*0.008-gunBob.x)*0.1;
            gunBob.y+=(Math.sin(bob*0.5)*0.012-gunBob.y)*0.1;
            gunBob.z+=(0-gunBob.z)*0.15;

            let fp=pitch+recoil.y+sway.y+shake.y;
            let fy=yaw+recoil.x+sway.x+shake.x;
            cam.quaternion.setFromEuler(new THREE.Euler(fp,fy,0,'YXZ'));

            if(curWep!==3||gunBob.z!==0){
                gunGrp.position.set(gunBob.x,gunBob.y,gunBob.z);
                gunGrp.rotation.set(-recoil.y*2,0,recoil.x*2);
            }

            document.getElementById('crosshair').style.transform=`translate(-50%, -50%) scale(${dir.length()>0?1.5:1})`;

            bullets=bullets.filter(b=>{
                b.life=(b.life||0)+1;
                if(b.life>60){scene.remove(b);return 0;}
                if(b.vel){b.position.add(b.vel);b.vel.y-=0.008;}
                return 1;
            });

            enemies.forEach(e=>{
                let ed=new THREE.Vector3().subVectors(cam.position,e.position).normalize();
                let np=e.position.clone().add(ed.multiplyScalar(e.spd));
                if(!checkCol(np,0.4))e.position.copy(np);
                if(e.position.distanceTo(cam.position)<2){
                    hp=Math.max(0,hp-0.5);updateHUD();
                    document.getElementById('damageOverlay').style.opacity='0.5';
                    setTimeout(()=>document.getElementById('damageOverlay').style.opacity='0',200);
                    if(hp<=0){
                        document.getElementById('finalScore').textContent=score;
                        document.getElementById('gameOver').style.display='block';
                        document.exitPointerLock();
                    }
                }
            });

            rend.render(scene,cam);
        }
        init();
    </script>
</body>
</html>
